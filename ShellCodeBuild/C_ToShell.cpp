#include "C_ToShell.h"


#include <WindowsSearchErrors.h>

char* get_file_data(const char* path, int* size);
bool save_file(const char* path, void* data, int size);
void free_file_data(const char* file_data);
bool save_file(const char* path, void* data, int size);
bool save_compress_file(const char* path, void* data, int size, int src_file_size);


char MyShellCode[] = 
{
0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x54, 0x53, 0x56, 0x57, 0xE8, 0x67, 0x06, 0x00,
0x00, 0x33, 0xDB, 0x89, 0x44, 0x24, 0x28, 0xC7, 0x44, 0x24, 0x14, 0x32, 0x32, 0x32, 0x32, 0xC7,
0x44, 0x24, 0x10, 0x33, 0x33, 0x33, 0x33, 0xC7, 0x44, 0x24, 0x0C, 0x34, 0x34, 0x34, 0x34, 0xC7,
0x44, 0x24, 0x44, 0x75, 0x73, 0x65, 0x72, 0xC7, 0x44, 0x24, 0x48, 0x33, 0x32, 0x2E, 0x64, 0x66,
0xC7, 0x44, 0x24, 0x4C, 0x6C, 0x6C, 0x88, 0x5C, 0x24, 0x4E, 0xC7, 0x44, 0x24, 0x50, 0x6B, 0x65,
0x72, 0x6E, 0xC7, 0x44, 0x24, 0x54, 0x65, 0x6C, 0x33, 0x32, 0xC7, 0x44, 0x24, 0x58, 0x2E, 0x64,
0x6C, 0x6C, 0x88, 0x5C, 0x24, 0x5C, 0xC7, 0x44, 0x24, 0x38, 0x6E, 0x74, 0x64, 0x6C, 0xC7, 0x44,
0x24, 0x3C, 0x6C, 0x2E, 0x64, 0x6C, 0x66, 0xC7, 0x44, 0x24, 0x40, 0x6C, 0x00, 0xE8, 0xFF, 0x05,
0x00, 0x00, 0xE8, 0x11, 0x06, 0x00, 0x00, 0x8B, 0xD0, 0x89, 0x44, 0x24, 0x2C, 0xB9, 0x87, 0x32,
0xD8, 0xC0, 0xE8, 0x20, 0x03, 0x00, 0x00, 0x53, 0x8B, 0xF0, 0x8D, 0x44, 0x24, 0x54, 0x53, 0x50,
0xFF, 0xD6, 0x6A, 0x00, 0x8B, 0xD8, 0x8D, 0x44, 0x24, 0x3C, 0x6A, 0x00, 0x50, 0xFF, 0xD6, 0x6A,
0x00, 0x8B, 0xF8, 0x8D, 0x44, 0x24, 0x48, 0x6A, 0x00, 0x50, 0xFF, 0xD6, 0x8B, 0xD3, 0xB9, 0x67,
0x59, 0xDE, 0x1E, 0xE8, 0xEF, 0x02, 0x00, 0x00, 0x8B, 0xD3, 0x89, 0x44, 0x24, 0x24, 0xB9, 0xBB,
0xF8, 0x29, 0x27, 0xE8, 0xDF, 0x02, 0x00, 0x00, 0x8B, 0xD3, 0x89, 0x44, 0x24, 0x30, 0xB9, 0xCA,
0xAF, 0x16, 0x22, 0xE8, 0xCF, 0x02, 0x00, 0x00, 0x8B, 0xD7, 0xB9, 0xD7, 0x6E, 0x8F, 0x81, 0x8B,
0xD8, 0xE8, 0xC1, 0x02, 0x00, 0x00, 0x8B, 0xF0, 0x33, 0xFF, 0x6A, 0x04, 0x8D, 0x44, 0x24, 0x10,
0x89, 0x7C, 0x24, 0x24, 0x50, 0x8D, 0x44, 0x24, 0x28, 0x89, 0x7C, 0x24, 0x24, 0x50, 0x89, 0x7C,
0x24, 0x24, 0xFF, 0xD6, 0x83, 0xC4, 0x0C, 0x8D, 0x44, 0x24, 0x10, 0x6A, 0x04, 0x50, 0x8D, 0x44,
0x24, 0x24, 0x50, 0xFF, 0xD6, 0x83, 0xC4, 0x0C, 0x8D, 0x44, 0x24, 0x14, 0x6A, 0x04, 0x50, 0x8D,
0x44, 0x24, 0x20, 0x50, 0xFF, 0xD6, 0x83, 0xC4, 0x0C, 0x6A, 0x40, 0x68, 0x00, 0x10, 0x00, 0x00,
0xFF, 0x74, 0x24, 0x20, 0x57, 0xFF, 0x54, 0x24, 0x34, 0x8B, 0x4C, 0x24, 0x20, 0x83, 0xEC, 0x10,
0x03, 0x4C, 0x24, 0x38, 0x8B, 0xF0, 0x8B, 0xD6, 0xFF, 0x74, 0x24, 0x28, 0xFF, 0x74, 0x24, 0x30,
0xE8, 0x3F, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x44, 0x83, 0xC4, 0x18, 0x8B, 0xCE, 0xE8, 0xDE,
0x02, 0x00, 0x00, 0x57, 0x57, 0x57, 0x50, 0x57, 0x57, 0xFF, 0x54, 0x24, 0x48, 0x6A, 0xFF, 0x50,
0xFF, 0xD3, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x56, 0x33, 0xF6, 0xEB, 0x09, 0xC1, 0xCE,
0x07, 0x0F, 0xBE, 0xC0, 0x03, 0xF0, 0x41, 0x8A, 0x01, 0x84, 0xC0, 0x75, 0xF1, 0x3B, 0xD6, 0x5E,
0x0F, 0x94, 0xC0, 0xC3, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x34, 0x53, 0x56, 0x57, 0x8B, 0x7D, 0x08,
0x8B, 0xC2, 0x89, 0x4D, 0xF4, 0x8B, 0xF1, 0x8B, 0xD8, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0x0C, 0x8D,
0x14, 0x39, 0xC7, 0x45, 0xD0, 0x01, 0x00, 0x00, 0x00, 0x8B, 0xCB, 0x89, 0x55, 0x08, 0x03, 0xC8,
0xC7, 0x45, 0xD4, 0x02, 0x00, 0x00, 0x00, 0x89, 0x4D, 0x0C, 0xC7, 0x45, 0xD8, 0x01, 0x00, 0x00,
0x00, 0x6A, 0x04, 0x59, 0x89, 0x4D, 0xCC, 0x89, 0x4D, 0xDC, 0x89, 0x4D, 0xE0, 0x89, 0x4D, 0xE4,
0x89, 0x4D, 0xE8, 0x8B, 0xCE, 0x85, 0xC0, 0x75, 0x19, 0x83, 0xFF, 0x01, 0x75, 0x0C, 0x80, 0x39,
0x00, 0x75, 0x07, 0x33, 0xC0, 0xE9, 0xF4, 0x00, 0x00, 0x00, 0x83, 0xC8, 0xFF, 0xE9, 0xEC, 0x00,
0x00, 0x00, 0x8B, 0x4D, 0x0C, 0x83, 0xC1, 0xF4, 0x89, 0x4D, 0xF0, 0x0F, 0xB6, 0x3E, 0x46, 0x89,
0x7D, 0xEC, 0xC1, 0xEF, 0x04, 0x83, 0xFF, 0x0F, 0x75, 0x18, 0xB8, 0xFF, 0x00, 0x00, 0x00, 0xEB,
0x0D, 0x3D, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x0A, 0x0F, 0xB6, 0x06, 0x46, 0x03, 0xF8, 0x3B, 0xF2,
0x72, 0xEF, 0x8D, 0x0C, 0x1F, 0x8D, 0x14, 0x37, 0x3B, 0x4D, 0xF0, 0x0F, 0x87, 0xF7, 0x00, 0x00,
0x00, 0x8B, 0x45, 0x08, 0x83, 0xC0, 0xF8, 0x3B, 0xD0, 0x0F, 0x87, 0xE9, 0x00, 0x00, 0x00, 0x8B,
0x06, 0x89, 0x03, 0x8B, 0x46, 0x04, 0x83, 0xC6, 0x08, 0x89, 0x43, 0x04, 0x83, 0xC3, 0x08, 0x3B,
0xD9, 0x72, 0xEC, 0x8B, 0xC1, 0x8B, 0xD1, 0x2B, 0xC3, 0x03, 0xF0, 0x0F, 0xB7, 0x06, 0x83, 0xC6,
0x02, 0x2B, 0xD0, 0x89, 0x45, 0xF8, 0x3B, 0x55, 0xFC, 0x72, 0x6D, 0x8B, 0x5D, 0xEC, 0x83, 0xE3,
0x0F, 0x83, 0xFB, 0x0F, 0x75, 0x1A, 0x8B, 0x7D, 0x08, 0x83, 0xC7, 0xFA, 0x3B, 0xF7, 0x73, 0x0D,
0x0F, 0xB6, 0x06, 0x46, 0x03, 0xD8, 0x3D, 0xFF, 0x00, 0x00, 0x00, 0x74, 0xEF, 0x8B, 0x45, 0xF8,
0x83, 0xF8, 0x04, 0x73, 0x26, 0x8A, 0x02, 0x88, 0x01, 0x8A, 0x42, 0x01, 0x88, 0x41, 0x01, 0x8A,
0x42, 0x02, 0x88, 0x41, 0x02, 0x8A, 0x42, 0x03, 0x88, 0x41, 0x03, 0x8B, 0x45, 0xF8, 0x03, 0x54,
0x85, 0xCC, 0x83, 0xC1, 0x04, 0x8B, 0x02, 0x89, 0x01, 0xEB, 0x0A, 0x8B, 0x02, 0x83, 0xC2, 0x04,
0x89, 0x01, 0x83, 0xC1, 0x04, 0x8B, 0x45, 0x0C, 0x03, 0xD9, 0x8D, 0x78, 0xF8, 0x3B, 0xDF, 0x76,
0x3E, 0x83, 0xC0, 0xFB, 0x3B, 0xD8, 0x76, 0x1B, 0x8B, 0x45, 0xF4, 0x2B, 0xC6, 0x48, 0x5F, 0x5E,
0x5B, 0xC9, 0xC3, 0x8B, 0x02, 0x89, 0x01, 0x8B, 0x42, 0x04, 0x89, 0x41, 0x04, 0x83, 0xC1, 0x08,
0x83, 0xC2, 0x08, 0x3B, 0xCF, 0x72, 0xEC, 0x3B, 0xCB, 0x73, 0x0C, 0x2B, 0xD1, 0x8A, 0x04, 0x0A,
0x88, 0x01, 0x41, 0x3B, 0xCB, 0x72, 0xF6, 0x8B, 0x55, 0x08, 0xE9, 0xEC, 0xFE, 0xFF, 0xFF, 0x6A,
0x04, 0x5F, 0x8B, 0x02, 0x03, 0xD7, 0x89, 0x01, 0x03, 0xCF, 0x8B, 0x02, 0x03, 0xD7, 0x89, 0x01,
0x03, 0xCF, 0x3B, 0xCB, 0x72, 0xEC, 0xEB, 0xDF, 0x3B, 0x55, 0x08, 0x75, 0xAB, 0x3B, 0x4D, 0x0C,
0x77, 0xA6, 0x57, 0x8B, 0xD6, 0x8B, 0xCB, 0xE8, 0x0B, 0x00, 0x00, 0x00, 0x83, 0xC4, 0x04, 0x2B,
0x7D, 0xFC, 0x8D, 0x04, 0x3B, 0xEB, 0x97, 0x55, 0x8B, 0xEC, 0x85, 0xC9, 0x74, 0x23, 0x85, 0xD2,
0x74, 0x1F, 0x56, 0x8B, 0x75, 0x08, 0x85, 0xF6, 0x74, 0x12, 0x57, 0x8D, 0x3C, 0x31, 0x2B, 0xD1,
0x4F, 0x8A, 0x04, 0x3A, 0x88, 0x07, 0x83, 0xEE, 0x01, 0x75, 0xF5, 0x5F, 0x8B, 0xC1, 0x5E, 0x5D,
0xC3, 0x33, 0xC0, 0x5D, 0xC3, 0x8B, 0x41, 0x3C, 0x0F, 0xB7, 0x44, 0x08, 0x04, 0xB9, 0x64, 0x86,
0x00, 0x00, 0x66, 0x3B, 0xC1, 0x74, 0x0D, 0xB9, 0x00, 0x02, 0x00, 0x00, 0x66, 0x3B, 0xC1, 0x74,
0x03, 0x32, 0xC0, 0xC3, 0xB0, 0x01, 0xC3, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x18, 0x53, 0x8B, 0xDA,
0x89, 0x4D, 0xFC, 0x56, 0x57, 0x8B, 0xCB, 0x8B, 0x7B, 0x3C, 0x03, 0xFB, 0xE8, 0xC4, 0xFF, 0xFF,
0xFF, 0x8D, 0x77, 0x78, 0x81, 0xC7, 0x88, 0x00, 0x00, 0x00, 0x3C, 0x01, 0x0F, 0x45, 0xFE, 0x33,
0xF6, 0x8B, 0x07, 0x03, 0xC3, 0x8B, 0x48, 0x1C, 0x8B, 0x50, 0x24, 0x03, 0xCB, 0x8B, 0x78, 0x18,
0x03, 0xD3, 0x89, 0x4D, 0xEC, 0x8B, 0x48, 0x20, 0x03, 0xCB, 0x89, 0x55, 0xF4, 0x89, 0x4D, 0xF8,
0x85, 0xFF, 0x74, 0x20, 0x8B, 0x55, 0xFC, 0x8B, 0x0C, 0xB1, 0x03, 0xCB, 0xE8, 0x78, 0xFD, 0xFF,
0xFF, 0x84, 0xC0, 0x75, 0x24, 0x8D, 0x47, 0xFF, 0x3B, 0xF0, 0x74, 0x17, 0x8B, 0x4D, 0xF8, 0x46,
0x3B, 0xF7, 0x72, 0xE3, 0x8B, 0x75, 0xE8, 0x8B, 0x4D, 0xEC, 0x8B, 0xC6, 0x8B, 0xD1, 0x5F, 0x5E,
0x5B, 0xC9, 0xC3, 0x33, 0xC0, 0x33, 0xD2, 0xEB, 0xF5, 0x8B, 0x45, 0xF4, 0x33, 0xC9, 0x0F, 0xB7,
0x04, 0x70, 0x8B, 0x75, 0xEC, 0x8B, 0x34, 0x86, 0x8B, 0xC3, 0x99, 0x03, 0xF0, 0x13, 0xCA, 0xEB,
0xD9, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x4C, 0x53, 0x33, 0xC0, 0x89, 0x4D, 0xFC, 0x56, 0x57, 0xB9,
0x87, 0x32, 0xD8, 0xC0, 0xC7, 0x45, 0xC4, 0x75, 0x73, 0x65, 0x72, 0xC7, 0x45, 0xC8, 0x33, 0x32,
0x2E, 0x64, 0x66, 0xC7, 0x45, 0xCC, 0x6C, 0x6C, 0x88, 0x45, 0xCE, 0xC7, 0x45, 0xB4, 0x6B, 0x65,
0x72, 0x6E, 0xC7, 0x45, 0xB8, 0x65, 0x6C, 0x33, 0x32, 0xC7, 0x45, 0xBC, 0x2E, 0x64, 0x6C, 0x6C,
0x88, 0x45, 0xC0, 0xC7, 0x45, 0xD0, 0x6E, 0x74, 0x64, 0x6C, 0xC7, 0x45, 0xD4, 0x6C, 0x2E, 0x64,
0x6C, 0x66, 0xC7, 0x45, 0xD8, 0x6C, 0x00, 0xE8, 0x0B, 0xFF, 0xFF, 0xFF, 0x33, 0xF6, 0x8B, 0xD8,
0x56, 0x56, 0x8D, 0x45, 0xB4, 0x89, 0x5D, 0xE4, 0x50, 0xFF, 0xD3, 0x56, 0x8B, 0xF8, 0x8D, 0x45,
0xD0, 0x56, 0x50, 0xFF, 0xD3, 0x6A, 0x00, 0x8B, 0xF0, 0x8D, 0x45, 0xC4, 0x6A, 0x00, 0x50, 0xFF,
0xD3, 0x8B, 0xD7, 0xB9, 0x67, 0x59, 0xDE, 0x1E, 0xE8, 0xDA, 0xFE, 0xFF, 0xFF, 0x8B, 0xD7, 0xB9,
0x85, 0xDF, 0xAF, 0xBB, 0x8B, 0xD8, 0xE8, 0xCC, 0xFE, 0xFF, 0xFF, 0x8B, 0xD6, 0x89, 0x45, 0xEC,
0xB9, 0xD7, 0x6E, 0x8F, 0x81, 0xE8, 0xBD, 0xFE, 0xFF, 0xFF, 0x89, 0x45, 0xF0, 0x8B, 0x45, 0xFC,
0x6A, 0x40, 0x8B, 0x78, 0x3C, 0x03, 0xF8, 0x89, 0x7D, 0xF8, 0x0F, 0xB7, 0x47, 0x14, 0x03, 0xC7,
0x89, 0x45, 0xE8, 0x0F, 0xB7, 0x47, 0x06, 0x89, 0x45, 0xF4, 0xB8, 0x00, 0x30, 0x00, 0x00, 0x50,
0xFF, 0x77, 0x50, 0x89, 0x45, 0xE0, 0x6A, 0x00, 0xFF, 0xD3, 0x8B, 0xF0, 0x89, 0x75, 0xDC, 0x85,
0xF6, 0x0F, 0x84, 0x19, 0x01, 0x00, 0x00, 0xFF, 0x77, 0x54, 0xFF, 0x75, 0xFC, 0x56, 0xFF, 0x55,
0xF0, 0x83, 0xC4, 0x0C, 0x83, 0x7D, 0xF4, 0x00, 0x76, 0x29, 0x8B, 0x5D, 0xE8, 0x8B, 0x7D, 0xF4,
0x83, 0xC3, 0x2C, 0xFF, 0x73, 0xFC, 0x8B, 0x03, 0x03, 0x45, 0xFC, 0x50, 0x8B, 0x43, 0xF8, 0x03,
0xC6, 0x50, 0xFF, 0x55, 0xF0, 0x83, 0xC4, 0x0C, 0x8D, 0x5B, 0x28, 0x83, 0xEF, 0x01, 0x75, 0xE3,
0x8B, 0x7D, 0xF8, 0x8B, 0xBF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFE, 0x89, 0x7D, 0xF0, 0x8B, 0x5F,
0x10, 0x8B, 0x4F, 0x0C, 0x03, 0xDE, 0x03, 0xCE, 0x83, 0x3B, 0x00, 0x74, 0x3C, 0x6A, 0x00, 0x6A,
0x00, 0x51, 0xFF, 0x55, 0xE4, 0x89, 0x45, 0xE8, 0x85, 0xC0, 0x0F, 0x84, 0xB0, 0x00, 0x00, 0x00,
0x8B, 0x0B, 0x8B, 0xF8, 0x85, 0xC9, 0x78, 0x08, 0x8D, 0x46, 0x02, 0x03, 0xC1, 0x50, 0xEB, 0x07,
0x81, 0xE1, 0xFF, 0xFF, 0xFF, 0x7F, 0x51, 0x57, 0xFF, 0x55, 0xEC, 0x89, 0x03, 0x83, 0xC3, 0x04,
0x8B, 0x0B, 0x85, 0xC9, 0x75, 0xE0, 0x8B, 0x7D, 0xF0, 0x83, 0xC7, 0x14, 0x89, 0x7D, 0xF0, 0x83,
0x7F, 0x0C, 0x00, 0x75, 0xA9, 0x8B, 0x55, 0xF8, 0x8B, 0xC6, 0x33, 0xDB, 0x2B, 0x42, 0x34, 0x89,
0x45, 0xE4, 0x8B, 0x82, 0xA0, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x64, 0x8D, 0x0C, 0x30, 0x8B,
0x82, 0xA4, 0x00, 0x00, 0x00, 0x89, 0x45, 0xEC, 0x85, 0xC0, 0x7E, 0x4D, 0x8B, 0x55, 0xE4, 0x8B,
0x01, 0x85, 0xC0, 0x74, 0x41, 0x03, 0xC6, 0x89, 0x45, 0xE8, 0x8B, 0x41, 0x04, 0x6A, 0x00, 0x8D,
0x78, 0xF8, 0xD1, 0xEF, 0x89, 0x7D, 0xE4, 0x5F, 0x74, 0x23, 0x8B, 0x75, 0xE4, 0x0F, 0xB7, 0x44,
0x79, 0x08, 0x66, 0x3B, 0x45, 0xE0, 0x72, 0x0A, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x03, 0x45, 0xE8,
0x01, 0x10, 0x47, 0x3B, 0xFE, 0x7C, 0xE6, 0x8B, 0x41, 0x04, 0x8B, 0x75, 0xDC, 0x03, 0xD8, 0x03,
0xC8, 0x3B, 0x5D, 0xEC, 0x7C, 0xB9, 0x8B, 0x55, 0xF8, 0x8B, 0x42, 0x28, 0x03, 0xC6, 0xEB, 0x02,
0x33, 0xC0, 0x5F, 0x5E, 0x5B, 0xC9, 0xC3, 0x57, 0x33, 0xFF, 0x57, 0x57, 0x57, 0x57, 0xFF, 0x15,
0x34, 0x30, 0x36, 0x01, 0xE8, 0x97, 0xF9, 0xFF, 0xFF, 0x57, 0x57, 0x57, 0x57, 0xFF, 0x15, 0x34,
0x30, 0x36, 0x01, 0x33, 0xC0, 0x5F, 0xC3, 0xCC, 0x8B, 0x04, 0x24, 0x25, 0x00, 0xF0, 0xFF, 0xFF,
0xC3, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x08, 0xC3, 0x56, 0x64, 0x8B, 0x35, 0x30,
0x00, 0x00, 0x00, 0x8B, 0x76, 0x0C, 0x5E, 0xC3, 0x56, 0x64, 0x8B, 0x35, 0x30, 0x00, 0x00, 0x00,
0x8B, 0x76, 0x0C, 0x8B, 0x76, 0x1C, 0x8B, 0x36, 0x8B, 0x76, 0x08, 0x8B, 0xC6, 0x5E, 0xC3, 0x55,
0x8B, 0xEC, 0x83, 0xEC, 0x50, 0x8B, 0x4D, 0x10, 0x8B, 0x75, 0x0C, 0x8B, 0x7D, 0x08, 0xF3, 0xA4,
0x83, 0xC4, 0x50, 0x8B, 0xE5, 0x5D, 0xC3, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x50, 0x8B, 0x7D, 0x08,
0x33, 0xC0, 0x8B, 0x4D, 0x0C, 0xFC, 0xF3, 0xAA, 0x83, 0xC4, 0x50, 0x8B, 0xE5, 0x5D, 0xC3
};


char MyShellCode64[] =
{
0x40, 0x55, 0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8D, 0x6C,
0x24, 0xE1, 0x48, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0xE8, 0x32, 0x07, 0x00, 0x00, 0x33, 0xDB,
0xC7, 0x45, 0x77, 0x32, 0x32, 0x32, 0x32, 0x88, 0x5D, 0xF9, 0x4C, 0x8B, 0xE8, 0x88, 0x5D, 0x0B,
0xC7, 0x45, 0x6F, 0x33, 0x33, 0x33, 0x33, 0xC7, 0x45, 0x67, 0x34, 0x34, 0x34, 0x34, 0xC7, 0x45,
0xEF, 0x75, 0x73, 0x65, 0x72, 0xC7, 0x45, 0xF3, 0x33, 0x32, 0x2E, 0x64, 0x66, 0xC7, 0x45, 0xF7,
0x6C, 0x6C, 0xC7, 0x45, 0xFF, 0x6B, 0x65, 0x72, 0x6E, 0xC7, 0x45, 0x03, 0x65, 0x6C, 0x33, 0x32,
0xC7, 0x45, 0x07, 0x2E, 0x64, 0x6C, 0x6C, 0xC7, 0x45, 0xDF, 0x6E, 0x74, 0x64, 0x6C, 0xC7, 0x45,
0xE3, 0x6C, 0x2E, 0x64, 0x6C, 0x66, 0xC7, 0x45, 0xE7, 0x6C, 0x00, 0xE8, 0x12, 0x07, 0x00, 0x00,
0xE8, 0x1F, 0x07, 0x00, 0x00, 0xEB, 0x03, 0x48, 0x8B, 0x00, 0x48, 0x8B, 0x48, 0x40, 0x66, 0x39,
0x59, 0x18, 0x75, 0xF3, 0x4C, 0x8B, 0x60, 0x10, 0xB9, 0x87, 0x32, 0xD8, 0xC0, 0x49, 0x8B, 0xD4,
0xE8, 0x9F, 0x03, 0x00, 0x00, 0x48, 0x8B, 0xD8, 0x48, 0x8D, 0x4D, 0xFF, 0x45, 0x33, 0xC0, 0x33,
0xD2, 0xFF, 0xD3, 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x4D, 0xDF, 0x33, 0xD2, 0x48, 0x8B, 0xF0, 0xFF,
0xD3, 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x4D, 0xEF, 0x33, 0xD2, 0x48, 0x8B, 0xF8, 0xFF, 0xD3, 0x48,
0x8B, 0xD6, 0xB9, 0x67, 0x59, 0xDE, 0x1E, 0xE8, 0x68, 0x03, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0xB9,
0xBB, 0xF8, 0x29, 0x27, 0x4C, 0x8B, 0xF0, 0xE8, 0x58, 0x03, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0xB9,
0xCA, 0xAF, 0x16, 0x22, 0x4C, 0x8B, 0xF8, 0xE8, 0x48, 0x03, 0x00, 0x00, 0x48, 0x8B, 0xD7, 0xB9,
0xD7, 0x6E, 0x8F, 0x81, 0x48, 0x8B, 0xF0, 0xE8, 0x38, 0x03, 0x00, 0x00, 0x48, 0x8B, 0xD8, 0x48,
0x8D, 0x55, 0x67, 0x33, 0xC0, 0x48, 0x8D, 0x4D, 0xD7, 0x89, 0x45, 0xD7, 0x89, 0x45, 0xDB, 0x89,
0x45, 0x7F, 0x8D, 0x78, 0x04, 0x44, 0x8B, 0xC7, 0xFF, 0xD3, 0x44, 0x8B, 0xC7, 0x48, 0x8D, 0x55,
0x6F, 0x48, 0x8D, 0x4D, 0xDB, 0xFF, 0xD3, 0x44, 0x8B, 0xC7, 0x48, 0x8D, 0x55, 0x77, 0x48, 0x8D,
0x4D, 0x7F, 0xFF, 0xD3, 0x8B, 0x55, 0x7F, 0x44, 0x8D, 0x4F, 0x3C, 0x33, 0xC9, 0x41, 0xB8, 0x00,
0x10, 0x00, 0x00, 0x41, 0xFF, 0xD6, 0x8B, 0x4D, 0xD7, 0x48, 0x8B, 0xD0, 0x44, 0x8B, 0x4D, 0x7F,
0x49, 0x03, 0xCD, 0x44, 0x8B, 0x45, 0xDB, 0x48, 0x8B, 0xD8, 0xE8, 0x41, 0x00, 0x00, 0x00, 0x49,
0x8B, 0xD4, 0x48, 0x8B, 0xCB, 0xE8, 0x62, 0x03, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00,
0x45, 0x33, 0xC9, 0x83, 0x64, 0x24, 0x20, 0x00, 0x4C, 0x8B, 0xC0, 0x33, 0xD2, 0x33, 0xC9, 0x41,
0xFF, 0xD7, 0x83, 0xCA, 0xFF, 0x48, 0x8B, 0xC8, 0xFF, 0xD6, 0x48, 0x81, 0xC4, 0x88, 0x00, 0x00,
0x00, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5E, 0x5B, 0x5D, 0xC3, 0xCC, 0xCC,
0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x55,
0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8D, 0x68, 0xC1, 0x48, 0x81, 0xEC, 0xA0,
0x00, 0x00, 0x00, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x4D, 0x63, 0xF0, 0x4C, 0x8B, 0xFA, 0x49, 0x63,
0xF1, 0x4C, 0x03, 0xF1, 0x48, 0x89, 0x45, 0x97, 0x48, 0x8B, 0xD9, 0x48, 0x89, 0x45, 0xB7, 0x44,
0x8D, 0x68, 0xFD, 0x48, 0x89, 0x45, 0xBF, 0x44, 0x8D, 0x58, 0xFE, 0x48, 0x89, 0x45, 0xC7, 0x48,
0x8B, 0xD1, 0x48, 0x89, 0x45, 0xCF, 0x33, 0xC0, 0x4C, 0x89, 0x6D, 0x9F, 0x48, 0x83, 0xC9, 0xFF,
0x4C, 0x89, 0x5D, 0xA7, 0x49, 0x03, 0xF7, 0x4C, 0x89, 0x6D, 0xAF, 0x48, 0x89, 0x45, 0xD7, 0x4D,
0x8B, 0xD7, 0x48, 0x89, 0x45, 0xDF, 0x48, 0x89, 0x45, 0xE7, 0x48, 0x89, 0x4D, 0xEF, 0x48, 0x89,
0x45, 0xF7, 0x4C, 0x89, 0x6D, 0xFF, 0x4C, 0x89, 0x5D, 0x07, 0x48, 0xC7, 0x45, 0x0F, 0x03, 0x00,
0x00, 0x00, 0x45, 0x85, 0xC9, 0x75, 0x14, 0x45, 0x3B, 0xC5, 0x75, 0x08, 0x38, 0x02, 0x0F, 0x84,
0x7D, 0x01, 0x00, 0x00, 0x8B, 0xC1, 0xE9, 0x76, 0x01, 0x00, 0x00, 0x4C, 0x8D, 0x66, 0xF4, 0x0F,
0xB6, 0x3A, 0x49, 0x03, 0xD5, 0x44, 0x8B, 0xDF, 0x49, 0xC1, 0xEB, 0x04, 0x49, 0x83, 0xFB, 0x0F,
0x75, 0x1D, 0xB9, 0xFF, 0x00, 0x00, 0x00, 0xEB, 0x11, 0x81, 0xF9, 0xFF, 0x00, 0x00, 0x00, 0x75,
0x0E, 0x0F, 0xB6, 0x0A, 0x49, 0x03, 0xD5, 0x4C, 0x03, 0xD9, 0x49, 0x3B, 0xD6, 0x72, 0xEA, 0x4F,
0x8D, 0x0C, 0x13, 0x4D, 0x3B, 0xCC, 0x0F, 0x87, 0x0C, 0x01, 0x00, 0x00, 0x49, 0x8D, 0x0C, 0x13,
0x49, 0x8D, 0x46, 0xF8, 0x48, 0x3B, 0xC8, 0x0F, 0x87, 0xFB, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x02,
0x48, 0x83, 0xC2, 0x08, 0x49, 0x89, 0x02, 0x49, 0x83, 0xC2, 0x08, 0x4D, 0x3B, 0xD1, 0x72, 0xED,
0x49, 0x8B, 0xC1, 0x4D, 0x8B, 0xC1, 0x49, 0x2B, 0xC2, 0x48, 0x03, 0xD0, 0x0F, 0xB7, 0x0A, 0x48,
0x83, 0xC2, 0x02, 0x4C, 0x2B, 0xC1, 0x4D, 0x3B, 0xC7, 0x0F, 0x82, 0xEB, 0x00, 0x00, 0x00, 0x83,
0xE7, 0x0F, 0x48, 0x83, 0xFF, 0x0F, 0x75, 0x16, 0x4D, 0x8D, 0x56, 0xFA, 0x49, 0x3B, 0xD2, 0x73,
0x0D, 0x0F, 0xB6, 0x02, 0x49, 0x03, 0xD5, 0x48, 0x03, 0xF8, 0x3C, 0xFF, 0x74, 0xEE, 0x48, 0x83,
0xF9, 0x08, 0x73, 0x31, 0x41, 0x8A, 0x00, 0x41, 0x88, 0x01, 0x41, 0x8A, 0x40, 0x01, 0x41, 0x88,
0x41, 0x01, 0x41, 0x8A, 0x40, 0x02, 0x41, 0x88, 0x41, 0x02, 0x41, 0x8A, 0x40, 0x03, 0x4C, 0x03,
0x44, 0xCD, 0x97, 0x41, 0x88, 0x41, 0x03, 0x41, 0x8B, 0x00, 0x4C, 0x2B, 0x44, 0xCD, 0xD7, 0x41,
0x89, 0x41, 0x04, 0xEB, 0x0A, 0x49, 0x8B, 0x00, 0x49, 0x83, 0xC0, 0x08, 0x49, 0x89, 0x01, 0x49,
0x8D, 0x49, 0x08, 0x4C, 0x8D, 0x57, 0xFC, 0x4C, 0x03, 0xD1, 0x4D, 0x3B, 0xD4, 0x76, 0x41, 0x48,
0x8D, 0x46, 0xFB, 0x4C, 0x3B, 0xD0, 0x77, 0x72, 0x4C, 0x8D, 0x4E, 0xF8, 0xEB, 0x0E, 0x49, 0x8B,
0x00, 0x48, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x49, 0x83, 0xC0, 0x08, 0x49, 0x3B, 0xC9, 0x72,
0xED, 0x49, 0x3B, 0xCA, 0x0F, 0x83, 0xE5, 0xFE, 0xFF, 0xFF, 0x4C, 0x2B, 0xC1, 0x41, 0x8A, 0x04,
0x08, 0x88, 0x01, 0x49, 0x03, 0xCD, 0x49, 0x3B, 0xCA, 0x72, 0xF2, 0xE9, 0xCF, 0xFE, 0xFF, 0xFF,
0x4C, 0x2B, 0xC1, 0x49, 0x8B, 0x04, 0x08, 0x48, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x49, 0x3B,
0xCA, 0x72, 0xF0, 0xE9, 0xB7, 0xFE, 0xFF, 0xFF, 0x49, 0x8D, 0x0C, 0x13, 0x49, 0x3B, 0xCE, 0x75,
0x19, 0x4C, 0x3B, 0xCE, 0x77, 0x14, 0x4D, 0x8B, 0xC3, 0x49, 0x8B, 0xCA, 0xE8, 0x33, 0x00, 0x00,
0x00, 0x45, 0x2B, 0xD7, 0x43, 0x8D, 0x04, 0x13, 0xEB, 0x07, 0x2B, 0xDA, 0x41, 0x2B, 0xDD, 0x8B,
0xC3, 0x4C, 0x8D, 0x9C, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x5B, 0x30, 0x49, 0x8B, 0x73,
0x38, 0x49, 0x8B, 0x7B, 0x40, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C,
0x5D, 0xC3, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x25, 0x48, 0x85, 0xD2, 0x74, 0x20, 0x4D, 0x85,
0xC0, 0x74, 0x17, 0x4E, 0x8D, 0x0C, 0x01, 0x48, 0x2B, 0xD1, 0x49, 0xFF, 0xC9, 0x42, 0x8A, 0x04,
0x0A, 0x41, 0x88, 0x01, 0x49, 0x83, 0xE8, 0x01, 0x75, 0xF0, 0x48, 0x8B, 0xC1, 0xC3, 0x33, 0xC0,
0xC3, 0xCC, 0xCC, 0xCC, 0x45, 0x33, 0xC0, 0xEB, 0x0D, 0x41, 0xC1, 0xC8, 0x07, 0x0F, 0xBE, 0xC0,
0x44, 0x03, 0xC0, 0x48, 0xFF, 0xC1, 0x8A, 0x01, 0x84, 0xC0, 0x75, 0xED, 0x41, 0x3B, 0xD0, 0x0F,
0x94, 0xC0, 0xC3, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x48, 0x89,
0x74, 0x24, 0x20, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x8B, 0xD2, 0x45, 0x33, 0xC9, 0x8B, 0xD1,
0x49, 0x63, 0x42, 0x3C, 0x46, 0x8B, 0x84, 0x10, 0x88, 0x00, 0x00, 0x00, 0x4D, 0x03, 0xC2, 0x41,
0x8B, 0x78, 0x1C, 0x41, 0x8B, 0x68, 0x20, 0x49, 0x03, 0xFA, 0x41, 0x8B, 0x70, 0x24, 0x49, 0x03,
0xEA, 0x45, 0x8B, 0x58, 0x18, 0x49, 0x03, 0xF2, 0x45, 0x85, 0xDB, 0x74, 0x22, 0x42, 0x8B, 0x4C,
0x8D, 0x00, 0x49, 0x03, 0xCA, 0xE8, 0x8A, 0xFF, 0xFF, 0xFF, 0x84, 0xC0, 0x75, 0x2F, 0x41, 0x8D,
0x43, 0xFF, 0x44, 0x3B, 0xC8, 0x74, 0x22, 0x41, 0xFF, 0xC1, 0x45, 0x3B, 0xCB, 0x72, 0xDE, 0x48,
0x8B, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x40, 0x48, 0x8B,
0x74, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x33, 0xC0, 0xEB, 0xE7, 0x42, 0x0F, 0xB7,
0x04, 0x4E, 0x8B, 0x04, 0x87, 0x49, 0x03, 0xC2, 0xEB, 0xDA, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24,
0x10, 0x55, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8B, 0xEC, 0x48,
0x83, 0xEC, 0x50, 0x33, 0xC0, 0xC7, 0x45, 0xE0, 0x75, 0x73, 0x65, 0x72, 0x4C, 0x8B, 0xF1, 0x88,
0x45, 0xEA, 0xB9, 0x87, 0x32, 0xD8, 0xC0, 0x88, 0x45, 0xFC, 0xC7, 0x45, 0xE4, 0x33, 0x32, 0x2E,
0x64, 0x66, 0xC7, 0x45, 0xE8, 0x6C, 0x6C, 0xC7, 0x45, 0xF0, 0x6B, 0x65, 0x72, 0x6E, 0xC7, 0x45,
0xF4, 0x65, 0x6C, 0x33, 0x32, 0xC7, 0x45, 0xF8, 0x2E, 0x64, 0x6C, 0x6C, 0xC7, 0x45, 0xD0, 0x6E,
0x74, 0x64, 0x6C, 0xC7, 0x45, 0xD4, 0x6C, 0x2E, 0x64, 0x6C, 0x66, 0xC7, 0x45, 0xD8, 0x6C, 0x00,
0xE8, 0xFF, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0xF0, 0x48, 0x89, 0x45, 0x50, 0x45, 0x33, 0xC0, 0x48,
0x8D, 0x4D, 0xF0, 0x33, 0xD2, 0xFF, 0xD6, 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x4D, 0xD0, 0x33, 0xD2,
0x48, 0x8B, 0xF8, 0xFF, 0xD6, 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x4D, 0xE0, 0x33, 0xD2, 0x48, 0x8B,
0xD8, 0xFF, 0xD6, 0x48, 0x8B, 0xD7, 0xB9, 0x67, 0x59, 0xDE, 0x1E, 0xE8, 0xC4, 0xFE, 0xFF, 0xFF,
0x48, 0x8B, 0xD7, 0xB9, 0x85, 0xDF, 0xAF, 0xBB, 0x48, 0x8B, 0xF0, 0xE8, 0xB4, 0xFE, 0xFF, 0xFF,
0x48, 0x8B, 0xD3, 0x48, 0x89, 0x45, 0x40, 0xB9, 0xD7, 0x6E, 0x8F, 0x81, 0xE8, 0xA3, 0xFE, 0xFF,
0xFF, 0x4D, 0x63, 0x7E, 0x3C, 0x33, 0xC9, 0x4D, 0x03, 0xFE, 0x41, 0xB8, 0x00, 0x30, 0x00, 0x00,
0x4C, 0x8B, 0xE0, 0x4C, 0x89, 0x7D, 0x58, 0x44, 0x8D, 0x49, 0x40, 0x41, 0x8B, 0x57, 0x50, 0x45,
0x0F, 0xB7, 0x6F, 0x06, 0xFF, 0xD6, 0x48, 0x8B, 0xD8, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x2E, 0x01,
0x00, 0x00, 0x45, 0x8B, 0x47, 0x54, 0x49, 0x8B, 0xD6, 0x48, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x41,
0x0F, 0xB7, 0x7F, 0x14, 0x33, 0xF6, 0x48, 0x83, 0xC7, 0x2C, 0x4D, 0x85, 0xED, 0x74, 0x23, 0x49,
0x03, 0xFF, 0x8B, 0x17, 0x8B, 0x4F, 0xF8, 0x49, 0x03, 0xD6, 0x44, 0x8B, 0x47, 0xFC, 0x48, 0x03,
0xCB, 0x41, 0xFF, 0xD4, 0xFF, 0xC6, 0x48, 0x8D, 0x7F, 0x28, 0x48, 0x63, 0xC6, 0x49, 0x3B, 0xC5,
0x72, 0xE0, 0x48, 0x63, 0x73, 0x3C, 0x48, 0x03, 0xF3, 0x44, 0x8B, 0xB6, 0x90, 0x00, 0x00, 0x00,
0x49, 0x83, 0xC6, 0x0C, 0x4C, 0x03, 0xF3, 0x41, 0x8B, 0x06, 0x85, 0xC0, 0x74, 0x53, 0x4C, 0x8B,
0x6D, 0x40, 0x4C, 0x8B, 0x7D, 0x50, 0x8B, 0xC8, 0x45, 0x33, 0xC0, 0x48, 0x03, 0xCB, 0x33, 0xD2,
0x41, 0xFF, 0xD7, 0x41, 0x8B, 0x7E, 0x04, 0x4C, 0x8B, 0xE0, 0x48, 0x03, 0xFB, 0xEB, 0x1B, 0x78,
0x09, 0x48, 0x8D, 0x53, 0x02, 0x48, 0x03, 0xD1, 0xEB, 0x03, 0x0F, 0xB7, 0xD1, 0x49, 0x8B, 0xCC,
0x41, 0xFF, 0xD5, 0x48, 0x89, 0x07, 0x48, 0x83, 0xC7, 0x08, 0x48, 0x8B, 0x0F, 0x48, 0x85, 0xC9,
0x75, 0xDD, 0x49, 0x83, 0xC6, 0x14, 0x41, 0x8B, 0x06, 0x85, 0xC0, 0x75, 0xB9, 0x4C, 0x8B, 0x7D,
0x58, 0x8B, 0x86, 0xB0, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xD3, 0x4C, 0x2B, 0x56, 0x30, 0x45, 0x33,
0xC9, 0x85, 0xC0, 0x74, 0x6B, 0x8B, 0xBE, 0xB4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0x03, 0x85,
0xFF, 0x7E, 0x54, 0x41, 0xBE, 0x00, 0x30, 0x00, 0x00, 0x83, 0x39, 0x00, 0x74, 0x49, 0x8B, 0x51,
0x04, 0x45, 0x33, 0xC0, 0x44, 0x8B, 0x19, 0x4C, 0x03, 0xDB, 0x48, 0x8D, 0x42, 0xF8, 0x48, 0xD1,
0xE8, 0x48, 0x63, 0xF0, 0x85, 0xC0, 0x7E, 0x22, 0x42, 0x0F, 0xB7, 0x44, 0x41, 0x08, 0x66, 0x41,
0x3B, 0xC6, 0x72, 0x0B, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x49, 0x03, 0xC3, 0x4C, 0x01, 0x10, 0x49,
0xFF, 0xC0, 0x4C, 0x3B, 0xC6, 0x7C, 0xE1, 0x8B, 0x51, 0x04, 0x8B, 0xC2, 0x44, 0x03, 0xCA, 0x48,
0x03, 0xC8, 0x44, 0x3B, 0xCF, 0x7C, 0xB2, 0x41, 0x8B, 0x47, 0x28, 0x48, 0x03, 0xC3, 0xEB, 0x02,
0x33, 0xC0, 0x48, 0x8B, 0x9C, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5F,
0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5E, 0x5D, 0xC3, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28,
0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x33, 0xC9, 0xFF, 0x15, 0x40, 0x19, 0x00, 0x00,
0xE8, 0xCB, 0xF8, 0xFF, 0xFF, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x33, 0xC9, 0xFF,
0x15, 0x2B, 0x19, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
0x48, 0x8B, 0x04, 0x24, 0x48, 0xBB, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x23,
0xC3, 0xC3, 0x48, 0x33, 0xC0, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8B,
0x40, 0x02, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00, 0xC3, 0x65, 0x48, 0x8B, 0x04,
0x25, 0x60, 0x00, 0x00, 0x00, 0xC3, 0xE8, 0xF1, 0xFF, 0xFF, 0xFF, 0x83, 0xC0, 0x18, 0x67, 0x8B,
0x00, 0xC3, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x60, 0x48,
0x8B, 0x40, 0x10, 0xC3, 0x56, 0x65, 0x48, 0x8B, 0x34, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8B,
0x76, 0x18, 0x48, 0x8B, 0x76, 0x30, 0x48, 0x8B, 0xC6, 0x5E, 0xC3, 0x55, 0x48, 0x8B, 0xEC, 0x48,
0x83, 0xEC, 0x50, 0x51, 0x52, 0x49, 0x8B, 0xC8, 0x5E, 0x5F, 0xF3, 0xA4, 0x48, 0x83, 0xC4, 0x50,
0x48, 0x8B, 0xE5, 0x5D, 0xC3, 0x48, 0x8B, 0xF9, 0x48, 0x33, 0xC0, 0x49, 0x8B, 0xC8, 0xFC, 0xF3,
0xAA
};


//压缩的信息返回出去
typedef struct COMPRESSINFO
{
	//预估压缩后的字节数  【压缩后的字节数】
	DWORD Retcompress_size;
	//文件原来的大小
	DWORD SrcFile_size;
	//返回的指针
	char* pRetNewBuffer;

}CompressInfo, * pCompressInfo;


typedef struct _SHAREDATA
{
	DWORD FirstExe = 0;			//ShellCode引导
	DWORD OldExeSize = 0;		//未压缩前的大小
	DWORD NowExeSize = 0;		//压缩后的大小
	DWORD DllSize = 0;			//当前把DLL中的代码导出后的大小 其实可以直接算出偏移，确保正确直接使用大小


	struct {
		DWORD Start;
		DWORD Size;
		BYTE Key;
	} Xor;


} SHAREDATA, * PSHAREDATA;

// 压缩
void compress(const char* path, pCompressInfo* RetInfo)
{
	int file_size = 0;
	char* file_data = get_file_data(path, &file_size);
	if (file_data == nullptr) {
		return;
	}

	//1. 获取预估的压缩后的字节数:
	int compress_size = LZ4_compressBound(file_size);
	// 2. 申请内存空间, 用于保存压缩后的数据
	char* pBuff = new char[compress_size];
	// 3. 开始压缩文件数据(函数返回压缩后的大小)
	int dest_size = LZ4_compress(
		file_data,	/*压缩前的数据*/
		pBuff,		/*压缩后的数据*/
		file_size	/*文件原始大小*/);

	printf("压缩前:%d , 压缩后:%d , 压缩比:%.2lf%%\n", file_size, dest_size, dest_size * 1.0 / file_size * 100.0);


	(*RetInfo)->pRetNewBuffer = pBuff;
	(*RetInfo)->Retcompress_size = dest_size;
	(*RetInfo)->SrcFile_size = file_size;
}

// 解压
void uncompress(const char* path)
{
	int file_size = 0;
	char* file_data = get_file_data(path, &file_size);
	if (file_data == nullptr) {
		return;
	}

	// 在保存压缩文件时, 先保存了4字节的原始文件大小, 然后再保存压缩后的文件数据
	//1. 先将前4字节的文件原始大小获取出来
	int src_file_size = *(int*)file_data;
	//2. 定位到压缩后的文件数据
	file_data += 4;

	//3. 申请空间
	char* pBuff = new char[src_file_size];

	//4. 解压缩
	LZ4_uncompress_unknownOutputSize(
		file_data,/*压缩后的数据*/
		pBuff, /*解压出来的数据*/
		file_size,/*压缩后的大小*/
		src_file_size/*压缩前的大小*/);


	printf("解压前:%d , 解压后:%d\n", file_size, src_file_size);

	save_file(path, pBuff, src_file_size);
}

char* get_file_data(const char* path, int* size)
{
	FILE* f = NULL;
	fopen_s(&f, path, "rb");
	if (f == nullptr) {
		return nullptr;
	}
	fseek(f, 0, SEEK_END);
	int file_size = ftell(f);
	char* file_data = new char[file_size];
	rewind(f);

	fread(file_data, 1, file_size, f);
	fclose(f);
	if (size) {
		*size = file_size;
	}
	return file_data;
}


void free_file_data(const char* file_data) {
	delete[] file_data;
}


bool save_file(const char* path, void* data, int size) {
	FILE* f = NULL;
	fopen_s(&f, path, "wb");
	if (f == nullptr) {
		return false;
	}
	fwrite((char*)data, 1, size, f);
	fclose(f);
	return true;
}


bool save_compress_file(const char* path, void* data, int size, int src_file_size) {
	FILE* f = NULL;
	fopen_s(&f, path, "wb");
	if (f == nullptr) {
		return false;
	}
	// 1. 写入文件的原始字节数
	fwrite(&src_file_size, 1, sizeof(src_file_size), f);
	// 2. 写入压缩后的文件内容
	fwrite((char*)data, 1, size, f);
	fclose(f);
	return true;
}

#define MEMORY_USAGE 14

/*
 * HEAPMODE :
 * Select how default compression functions will allocate memory for their hash table,
 * in memory stack (0:default, fastest), or in memory heap (1:requires memory allocation (malloc)).
 */
#define HEAPMODE 0


 /**************************************
	CPU Feature Detection
 **************************************/
 /* 32 or 64 bits ? */
#if (defined(__x86_64__) || defined(_M_X64) || defined(_WIN64) \
  || defined(__powerpc64__) || defined(__ppc64__) || defined(__PPC64__) \
  || defined(__64BIT__) || defined(_LP64) || defined(__LP64__) \
  || defined(__ia64) || defined(__itanium__) || defined(_M_IA64) )   /* Detects 64 bits mode */
#  define LZ4_ARCH64 1
#else
#  define LZ4_ARCH64 0
#endif

/*
 * Little Endian or Big Endian ?
 * Overwrite the #define below if you know your architecture endianess
 */
#if defined (__GLIBC__)
#  include <endian.h>
#  if (__BYTE_ORDER == __BIG_ENDIAN)
#     define LZ4_BIG_ENDIAN 1
#  endif
#elif (defined(__BIG_ENDIAN__) || defined(__BIG_ENDIAN) || defined(_BIG_ENDIAN)) && !(defined(__LITTLE_ENDIAN__) || defined(__LITTLE_ENDIAN) || defined(_LITTLE_ENDIAN))
#  define LZ4_BIG_ENDIAN 1
#elif defined(__sparc) || defined(__sparc__) \
   || defined(__powerpc__) || defined(__ppc__) || defined(__PPC__) \
   || defined(__hpux)  || defined(__hppa) \
   || defined(_MIPSEB) || defined(__s390__)
#  define LZ4_BIG_ENDIAN 1
#else
 /* Little Endian assumed. PDP Endian and other very rare endian format are unsupported. */
#endif

/*
 * Unaligned memory access is automatically enabled for "common" CPU, such as x86.
 * For others CPU, such as ARM, the compiler may be more cautious, inserting unnecessary extra code to ensure aligned access property
 * If you know your target CPU supports unaligned memory access, you want to force this option manually to improve performance
 */
#if defined(__ARM_FEATURE_UNALIGNED)
#  define LZ4_FORCE_UNALIGNED_ACCESS 1
#endif

 /* Define this parameter if your target system or compiler does not support hardware bit count */
#if defined(_MSC_VER) && defined(_WIN32_WCE)   /* Visual Studio for Windows CE does not support Hardware bit count */
#  define LZ4_FORCE_SW_BITCOUNT
#endif

/*
 * BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE :
 * This option may provide a small boost to performance for some big endian cpu, although probably modest.
 * You may set this option to 1 if data will remain within closed environment.
 * This option is useless on Little_Endian CPU (such as x86)
 */

 /* #define BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE 1 */


 /**************************************
  Compiler Options
 **************************************/
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)   /* C99 */
 /* "restrict" is a known keyword */
#else
#  define restrict /* Disable restrict */
#endif

#ifdef _MSC_VER    /* Visual Studio */
#  define FORCE_INLINE static __forceinline
#  include <intrin.h>                    /* For Visual 2005 */
#  if LZ4_ARCH64   /* 64-bits */
#    pragma intrinsic(_BitScanForward64) /* For Visual 2005 */
#    pragma intrinsic(_BitScanReverse64) /* For Visual 2005 */
#  else            /* 32-bits */
#    pragma intrinsic(_BitScanForward)   /* For Visual 2005 */
#    pragma intrinsic(_BitScanReverse)   /* For Visual 2005 */
#  endif
#  pragma warning(disable : 4127)        /* disable: C4127: conditional expression is constant */
#else
#  ifdef __GNUC__
#    define FORCE_INLINE static inline __attribute__((always_inline))
#  else
#    define FORCE_INLINE static inline
#  endif
#endif

#ifdef _MSC_VER  /* Visual Studio */
#  define lz4_bswap16(x) _byteswap_ushort(x)
#else
#  define lz4_bswap16(x) ((unsigned short int) ((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8)))
#endif

#define GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)

#if (GCC_VERSION >= 302) || (__INTEL_COMPILER >= 800) || defined(__clang__)
#  define expect(expr,value)    (__builtin_expect ((expr),(value)) )
#else
#  define expect(expr,value)    (expr)
#endif

#define likely(expr)     expect((expr) != 0, 1)
#define unlikely(expr)   expect((expr) != 0, 0)


 /**************************************
	Memory routines
 **************************************/
#include <stdlib.h>   /* malloc, calloc, free */
#define ALLOCATOR(n,s) calloc(n,s)
#define FREEMEM        free
#include <string.h>   /* memset, memcpy */
#define MEM_INIT       memset


 /**************************************
	Includes
 **************************************/
#include "lz4.h"


 /**************************************
	Basic Types
 **************************************/
#if defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)   /* C99 */
# include <stdint.h>
typedef  uint8_t BYTE;
typedef uint16_t U16;
typedef uint32_t U32;
typedef  int32_t S32;
typedef uint64_t U64;
#else
typedef unsigned char       BYTE;
typedef unsigned short      U16;
typedef unsigned int        U32;
typedef   signed int        S32;
typedef unsigned long long  U64;
#endif

#if defined(__GNUC__)  && !defined(LZ4_FORCE_UNALIGNED_ACCESS)
#  define _PACKED __attribute__ ((packed))
#else
#  define _PACKED
#endif

#if !defined(LZ4_FORCE_UNALIGNED_ACCESS) && !defined(__GNUC__)
#  if defined(__IBMC__) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
#    pragma pack(1)
#  else
#    pragma pack(push, 1)
#  endif
#endif

typedef struct { U16 v; }  _PACKED U16_S;
typedef struct { U32 v; }  _PACKED U32_S;
typedef struct { U64 v; }  _PACKED U64_S;
typedef struct { size_t v; } _PACKED size_t_S;

#if !defined(LZ4_FORCE_UNALIGNED_ACCESS) && !defined(__GNUC__)
#  if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
#    pragma pack(0)
#  else
#    pragma pack(pop)
#  endif
#endif

#define A16(x)   (((U16_S *)(x))->v)
#define A32(x)   (((U32_S *)(x))->v)
#define A64(x)   (((U64_S *)(x))->v)
#define AARCH(x) (((size_t_S *)(x))->v)


/**************************************
   Constants
**************************************/
#define LZ4_HASHLOG   (MEMORY_USAGE-2)
#define HASHTABLESIZE (1 << MEMORY_USAGE)
#define HASHNBCELLS4  (1 << LZ4_HASHLOG)

#define MINMATCH 4

#define COPYLENGTH 8
#define LASTLITERALS 5
#define MFLIMIT (COPYLENGTH+MINMATCH)
static const int LZ4_minLength = (MFLIMIT + 1);

#define KB *(1U<<10)
#define MB *(1U<<20)
#define GB *(1U<<30)

#define LZ4_64KLIMIT ((64 KB) + (MFLIMIT-1))
#define SKIPSTRENGTH 6   /* Increasing this value will make the compression run slower on incompressible data */

#define MAXD_LOG 16
#define MAX_DISTANCE ((1 << MAXD_LOG) - 1)

#define ML_BITS  4
#define ML_MASK  ((1U<<ML_BITS)-1)
#define RUN_BITS (8-ML_BITS)
#define RUN_MASK ((1U<<RUN_BITS)-1)


/**************************************
   Structures and local types
**************************************/
typedef struct {
	U32 hashTable[HASHNBCELLS4];
	const BYTE* bufferStart;
	const BYTE* base;
	const BYTE* nextBlock;
} LZ4_Data_Structure;

typedef enum { notLimited = 0, limited = 1 } limitedOutput_directive;
typedef enum { byPtr, byU32, byU16 } tableType_t;

typedef enum { noPrefix = 0, withPrefix = 1 } prefix64k_directive;

typedef enum { endOnOutputSize = 0, endOnInputSize = 1 } endCondition_directive;
typedef enum { full = 0, partial = 1 } earlyEnd_directive;


/**************************************
   Architecture-specific macros
**************************************/
#define STEPSIZE                  sizeof(size_t)
#define LZ4_COPYSTEP(d,s)         { AARCH(d) = AARCH(s); d+=STEPSIZE; s+=STEPSIZE; }
#define LZ4_COPY8(d,s)            { LZ4_COPYSTEP(d,s); if (STEPSIZE<8) LZ4_COPYSTEP(d,s); }

#if (defined(LZ4_BIG_ENDIAN) && !defined(BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE))
#  define LZ4_READ_LITTLEENDIAN_16(d,s,p) { U16 v = A16(p); v = lz4_bswap16(v); d = (s) - v; }
#  define LZ4_WRITE_LITTLEENDIAN_16(p,i)  { U16 v = (U16)(i); v = lz4_bswap16(v); A16(p) = v; p+=2; }
#else      /* Little Endian */
#  define LZ4_READ_LITTLEENDIAN_16(d,s,p) { d = (s) - A16(p); }
#  define LZ4_WRITE_LITTLEENDIAN_16(p,v)  { A16(p) = v; p+=2; }
#endif


/**************************************
   Macros
**************************************/
#if LZ4_ARCH64 || !defined(__GNUC__)
#  define LZ4_WILDCOPY(d,s,e)     { do { LZ4_COPY8(d,s) } while (d<e); }           /* at the end, d>=e; */
#else
#  define LZ4_WILDCOPY(d,s,e)     { if (likely(e-d <= 8)) LZ4_COPY8(d,s) else do { LZ4_COPY8(d,s) } while (d<e); }
#endif
#define LZ4_SECURECOPY(d,s,e)     { if (d<e) LZ4_WILDCOPY(d,s,e); }


FORCE_INLINE int LZ4_decompress_generic(
	const char* source,
	char* dest,
	int inputSize,
	int outputSize,         /* If endOnInput==endOnInputSize, this value is the max size of Output Buffer. */
	int endOnInput,         /* endOnOutputSize,*/
	int prefix64k,          /* noPrefix,*/
	int partialDecoding,    /* full,*/
	int targetOutputSize    /* 0,*/
)
{
	/* Local Variables */
	const BYTE* restrict ip = (const BYTE*)source;
	const BYTE* ref;
	const BYTE* const iend = ip + inputSize;

	BYTE* op = (BYTE*)dest;
	BYTE* const oend = op + outputSize;
	BYTE* cpy;
	BYTE* oexit = op + targetOutputSize;

	/*const size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};   / static reduces speed for LZ4_decompress_safe() on GCC64 */
	const size_t dec32table[] = { 4 - 0, 4 - 3, 4 - 2, 4 - 3, 4 - 0, 4 - 0, 4 - 0, 4 - 0 };   /* static reduces speed for LZ4_decompress_safe() on GCC64 */
	static const size_t dec64table[] = { 0, 0, 0, (size_t)-1, 0, 1, 2, 3 };


	/* Special cases */
	if ((partialDecoding) && (oexit > oend - MFLIMIT)) oexit = oend - MFLIMIT;                        /* targetOutputSize too high => decode everything */
	if ((endOnInput) && (unlikely(outputSize == 0))) return ((inputSize == 1) && (*ip == 0)) ? 0 : -1;   /* Empty output buffer */
	if ((!endOnInput) && (unlikely(outputSize == 0))) return (*ip == 0 ? 1 : -1);



#define COPYLENGTH 8
#define LASTLITERALS 5

	/* Main Loop */
	while (1)
	{
		unsigned token;
		size_t length;

		/* get runlength */
		token = *ip++;
		if ((length = (token >> ML_BITS)) == RUN_MASK)
		{
			unsigned s = 255;
			while (((endOnInput) ? ip < iend : 1) && (s == 255))
			{
				s = *ip++;
				length += s;
			}
		}

		/* copy literals */
		cpy = op + length;
		if (((endOnInput) && ((cpy > (partialDecoding ? oexit : oend - MFLIMIT)) || (ip + length > iend - (2 + 1 + LASTLITERALS))))
			|| ((!endOnInput) && (cpy > oend - COPYLENGTH)))
		{
			if (partialDecoding)
			{
				if (cpy > oend) goto _output_error;                           /* Error : write attempt beyond end of output buffer */
				if ((endOnInput) && (ip + length > iend)) goto _output_error;   /* Error : read attempt beyond end of input buffer */
			}
			else
			{
				if ((!endOnInput) && (cpy != oend)) goto _output_error;       /* Error : block decoding must stop exactly there */
				if ((endOnInput) && ((ip + length != iend) || (cpy > oend))) goto _output_error;   /* Error : input must be consumed */
			}
			memcpy(op, ip, length);
			//memcpy(op, ip, length);
			ip += length;
			op += length;
			break;                                       /* Necessarily EOF, due to parsing restrictions */
		}
		LZ4_WILDCOPY(op, ip, cpy); ip -= (op - cpy); op = cpy;

		/* get offset */
		LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip); ip += 2;
		if ((prefix64k == noPrefix) && (unlikely(ref < (BYTE* const)dest))) goto _output_error;   /* Error : offset outside destination buffer */

		/* get matchlength */
		if ((length = (token & ML_MASK)) == ML_MASK)
		{
			while ((!endOnInput) || (ip < iend - (LASTLITERALS + 1)))   /* Ensure enough bytes remain for LASTLITERALS + token */
			{
				unsigned s = *ip++;
				length += s;
				if (s == 255) continue;
				break;
			}
		}

		/* copy repeated sequence */
		if (unlikely((op - ref) < (int)STEPSIZE))
		{
			const size_t dec64 = dec64table[(sizeof(void*) == 4) ? 0 : op - ref];
			op[0] = ref[0];
			op[1] = ref[1];
			op[2] = ref[2];
			op[3] = ref[3];
			/*op += 4, ref += 4; ref -= dec32table[op-ref];
			A32(op) = A32(ref);
			op += STEPSIZE-4; ref -= dec64;*/
			ref += dec32table[op - ref];
			A32(op + 4) = A32(ref);
			op += STEPSIZE; ref -= dec64;
		}
		else { LZ4_COPYSTEP(op, ref); }
		cpy = op + length - (STEPSIZE - 4);

		if (unlikely(cpy > oend - COPYLENGTH - (STEPSIZE - 4)))
		{
			if (cpy > oend - LASTLITERALS) goto _output_error;    /* Error : last 5 bytes must be literals */
			LZ4_SECURECOPY(op, ref, (oend - COPYLENGTH));
			while (op < cpy) *op++ = *ref++;
			op = cpy;
			continue;
		}
		LZ4_WILDCOPY(op, ref, cpy);
		op = cpy;   /* correction */
	}

	/* end of decoding */
	if (endOnInput)
		return (int)(((char*)op) - dest);     /* Nb of output bytes decoded */
	else
		return (int)(((char*)ip) - source);   /* Nb of input bytes read */

	 /* Overflow error detected */
_output_error:
	return (int)(-(((char*)ip) - source)) - 1;
}

int memfind(const char* mem, int sizem, const char* str,  int sizes)
{
	int   da, i, j;
	if (sizes == 0) da = strlen(str);
	else da = sizes;
	for (i = 0; i < sizem; i++)
	{
		for (j = 0; j < da; j++)
			if (mem[i + j] != str[j])	break;
		if (j == da) return i;
	}
	return -1;
}

DWORD TO_SHELL(string SrcFile, string OutFile)
{

	DWORD DllSize = 0, dwRetBuf;




	//对文件压缩------------------------------------------------
	pCompressInfo NewFileInfo = new CompressInfo{ 0 };
	//压缩完成
	compress(SrcFile.c_str(), &NewFileInfo);



#ifdef _WIN64

	//64--------------------------------------------------------------------Start

	int OldExeSizeFoa32Point = memfind(MyShellCode64, _countof(MyShellCode64), "2222", 0);
	int NowExeSizeFoa32Point = memfind(MyShellCode64, _countof(MyShellCode64), "3333", 0);
	int ShellRvaFoa32Point = memfind(MyShellCode64, _countof(MyShellCode64), "4444", 0);
	* (LPDWORD)(&MyShellCode64[OldExeSizeFoa32Point]) = NewFileInfo->SrcFile_size;

	*(LPDWORD)(&MyShellCode64[NowExeSizeFoa32Point]) = NewFileInfo->Retcompress_size;

	*(LPDWORD)(&MyShellCode64[ShellRvaFoa32Point]) = _countof(MyShellCode64);

	DWORD ShellCodeSize = (_countof(MyShellCode64) + (NewFileInfo->Retcompress_size));
	char* File_All = (char*)VirtualAlloc(NULL, ShellCodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	//复制区段
	memcpy((File_All), MyShellCode64, _countof(MyShellCode64));
	memcpy((File_All + (_countof(MyShellCode64))), NewFileInfo->pRetNewBuffer, (NewFileInfo->Retcompress_size));

	//----------------------------------------------------------------------------------64End

#else

	//----------------------------------------------------------------32


	//--------------------------------------填写共享信息

	//这里指 压缩文件的位置
		//共享字段
	//CHAR OldExeSize[] = { '2','2','2','2' };					//未压缩前的大小
	//CHAR NowExeSize[] = { '3','3','3','3' };					//压缩后的大小
	//CHAR ShellRva[] = { '4','4','4','4' };					//PE压缩后的文件放入shellcode之后

	//DWORD OldExeSizeFoa32 = 27;
	//DWORD NowExeSizeFoa32 = 35;
	//DWORD ShellRvaFoa32 = 43;
	//26 - 29 OldExeSize
	//35 - 38 NowExeSize
	//42 - 45 ShellRva
	int OldExeSizeFoa32Point = memfind(MyShellCode, _countof(MyShellCode), "2222", 0);
	int NowExeSizeFoa32Point = memfind(MyShellCode, _countof(MyShellCode), "3333", 0);
	int ShellRvaFoa32Point = memfind(MyShellCode, _countof(MyShellCode), "4444", 0);

	if (OldExeSizeFoa32Point <= 0 || NowExeSizeFoa32Point <= 0 || ShellRvaFoa32Point <= 0) 
	{
		MessageBox(NULL, L"未找到特征点", L"未找到特征", 0);
	}


	DWORD offset = 1;
	DWORD r1, r2, r3, r4;
	char* Buffer = new char[0x200]{ 0 };
	sprintf(Buffer, "%08x", NewFileInfo->SrcFile_size);
	sscanf(Buffer, "%2x%2x%2x%2x", &r1, &r2, &r3, &r4);
	MyShellCode[OldExeSizeFoa32Point] = r4;
	MyShellCode[OldExeSizeFoa32Point + 1] = r3;
	MyShellCode[OldExeSizeFoa32Point + 2] = r2;
	MyShellCode[OldExeSizeFoa32Point + 3] = r1;

	memset(Buffer, 0, 0x200);
	sprintf(Buffer, "%08x", NewFileInfo->Retcompress_size);
	sscanf(Buffer, "%2x%2x%2x%2x", &r1, &r2, &r3, &r4);
	MyShellCode[NowExeSizeFoa32Point] = r4;
	MyShellCode[NowExeSizeFoa32Point + 1] = r3;
	MyShellCode[NowExeSizeFoa32Point + 2] = r2;
	MyShellCode[NowExeSizeFoa32Point + 3] = r1;

	memset(Buffer, 0, 0x200);
	sprintf(Buffer, "%08x", _countof(MyShellCode));
	sscanf(Buffer, "%2x%2x%2x%2x", &r1, &r2, &r3, &r4);
	MyShellCode[ShellRvaFoa32Point] = r4;
	MyShellCode[ShellRvaFoa32Point + 1] = r3;
	MyShellCode[ShellRvaFoa32Point + 2] = r2;
	MyShellCode[ShellRvaFoa32Point + 3] = r1;

	//前置引导  +EXE
	DWORD ShellCodeSize = (_countof(MyShellCode) + (NewFileInfo->Retcompress_size));
	char* File_All = (char*)VirtualAlloc(NULL, ShellCodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy((File_All), MyShellCode, _countof(MyShellCode));
	memcpy((File_All + (_countof(MyShellCode))), NewFileInfo->pRetNewBuffer, (NewFileInfo->Retcompress_size));

#endif // _WIN64


	//---------------------------------------写入文件
	HANDLE NFile;
	do
	{

		NFile = CreateFileA(OutFile.c_str(), GENERIC_ALL, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, FALSE);

	} while (GetLastError() == ERROR_ALREADY_EXISTS && DeleteFileA(OutFile.c_str()));

	//
	if (GetLastError() == ERROR_ACCESS_DENIED) 
	{
	
		MessageBox(NULL,L"出现错误，请用管理员权限重试",L"ERROR!",0);
	
	}

	//生成的是ShellCode
	WriteFile(NFile, (char*)File_All, ShellCodeSize, &dwRetBuf, FALSE);
	
	CloseHandle(NFile);

	return 0;

}



